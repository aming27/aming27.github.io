---
ID: 100
title: >
  Sobre WCF, DTO, EF, POCO y los
  principios de la programaci√≥n
author: fernandoescolar
post_date: 2012-01-22 18:45:36
post_excerpt: ""
layout: post
---
<p>Creo que este es el primer art&iacute;culo que vamos a ver en <a href="http://www.programandonet.com"><strong>programandonet</strong></a> a modo editorial. Esto es el resultado de <a href="http://www.linkedin.com/groups/WCF-DTO-vs-WCF-POCO-2615616.S.89901834?qid=56f3138d-d4ae-4072-9eb3-617867092b49&amp;trk=group_most_popular-0-b-ttl&amp;goback=%2Egmp_2615616" target="_blank">una conversaci&oacute;n</a> en el <a href="http://www.linkedin.com/groups/Arquitectos-NET-2615616?trk=myg_ugrp_ovr" target="_blank">grupo de <em>arquitectos .net</em></a>&nbsp;de <a href="http://www.linkedin.com" target="_blank">LinkedIn</a>, en la que se hablaba sobre usar <strong>POCO</strong>s de entity framework como <strong>DTO</strong> para servicios <strong>WCF</strong>, que se inici&oacute; hace unos d&iacute;as. Y es que, no me hubiera gustado que algunas conclusiones y escritos se <em>perdieran</em> en este grupo y por eso hemos cre&iacute;do interesante publicarlas aqu&iacute;, para tenerlas <em>a mano</em>.</p>
<!--break-->
<p>Para aquellas personas que no est&eacute;n familiarizadas con estas siglas haremos un breve glosario:</p>
<ul>
<li><b>POCO</b>: Son las siglas de <strong>P</strong>lain <strong>O</strong>ld <strong>C</strong># <strong>O</strong>bject, y se refieren a clases simples que no dependen de ninguna framework. Es un t&eacute;rmino derivado del concepto del mundo Java: <strong>POJO</strong>.</li>
<li><b>EF</b>: <strong>E</strong>ntity <strong>F</strong>ramework es un <strong>ORM</strong> dise&ntilde;ado por Microsoft, sirve para convertir en un lenguaje orientado a objetos (como c#), una base de datos relacional. En sus &uacute;ltimas versiones permite el uso de <strong>POCO</strong>s como entidades de las bases de datos.</li>
<li><b>DTO</b>: Se refiere a <strong>D</strong>ata <strong>T</strong>ransfer <strong>O</strong>bjects y es un objeto que por definici&oacute;n se env&iacute;a y recibe dentro de un servicio. Nuestro compa&ntilde;ero <a href="https://twitter.com/pbousan" target="_blank"><strong>@pbousan</strong></a> hace referencia a <a href="http://www.linkedin.com/redirect?url=http%3A%2F%2Fmartinfowler%2Ecom%2FeaaCatalog%2FdataTransferObject%2Ehtml&amp;urlhash=R8WJ&amp;_t=tracking_disc" target="_blank">este art&iacute;culo de Martin Fowler</a> donde explica el concepto.</li>
<li><b>WCF</b>: Es la abreviaci&oacute;n de <strong>W</strong>indows <strong>C</strong>ommunication <strong>F</strong>oundation, que es una API de Microsoft para crear aplicaciones orientadas a los servicios (SOA). De lo que deducimos que los objetos que se env&iacute;an o reciben en estos servicios son DTOs.</li>
</ul>
<p>Si retomamos la cuesti&oacute;n inicial, la primera conclusi&oacute;n que desarrollamos fue que: <strong>si usas objetos POCO de Entity Framework como DTO, le est&aacute;s dando dos responsabilidades a tu objeto</strong>. Por un lado sirve de entidad del ORM y por otro de transferencia de WCF. Por lo que <strong>estar&iacute;as incumpliendo la S de los principios SOLID</strong>: Single responsibility principle (SRP). Por lo tanto la respuesta es que no deber&iacute;amos hacerlo.</p>
<p>Adem&aacute;s al darle estas dos responsabilidades a un objeto, obligas a que tus servicios env&iacute;en "toda" la informaci&oacute;n que almacenas en la base de datos, y quiz&aacute; solo hace falta una parte de esa informaci&oacute;n. Entonces corres el riesgo de enviar demasiada informaci&oacute;n con un servicio, o demasiada poca, haciendo necesario llamar a dos m&eacute;todos diferentes. Es decir, un alto riesgo de crear servicios poco eficientes.</p>
<p>Pero existe el contexto en el que los datos almacenados sean exactamente los mismos que queremos enviar en nuestros servicios. En este sentido <strong><a href="https://twitter.com/#!/jc_quijano" target="_blank">@jc_quijano</a></strong> defendi&oacute; una postura que se amparaba en el principio de la programaci&oacute;n <strong>KISS</strong> (Keep It Simple, Stupid!). Es decir, <strong>es m&aacute;s r&aacute;pido y f&aacute;cil desarrollar un POCO para EF y reutilizarlo como DTO</strong> para nuestros servicios. Adem&aacute;s, <strong>si se a&ntilde;aden DTOs</strong> a este concepto, <strong>estamos a&ntilde;adiendo una capa nueva de complejidad a la aplicaci&oacute;n</strong>. Y como no es la estructura de los objetos lo que me definen su responsabilidad, si no el uso que le doy a esos objetos,<strong> estructuralmente, tampoco estoy rompiendo ning&uacute;n principio SOLID</strong>.</p>
<p></p>
<p>Esta filosof&iacute;a me parece correcta a la hora de desarrollar aplicaciones con un ciclo de vida muy corto. Como puede ser una herramienta que ayuda a corregir un problema puntual y que una vez corregido, podemos deshacernos de esta. De esa forma no tendr&iacute;a un mantenimiento largo y no se convertir&iacute;a en un problema el acoplamiento que crea usar un objeto para dos tareas diferentes.</p>
<p>Y es que KISS no es un principio m&aacute;s importante que el SRP o que cualquiera de SOLID. Ni un principio de SOLID es m&aacute;s importante que cualquier otro principio (incluido KISS). Los principios SOLID te llevan a programar mejor e indirectamente a empezar a seguir otros principios como KISS o YAGNI. Mi opini&oacute;n y recomendaci&oacute;n es seguirlos todos.</p>
<p>El principio <strong>KISS no debe confundirse con programar poco</strong>, si no que lo que programes hacerlo simple. No a&ntilde;adir 20 capas a una soluci&oacute;n que con 2 va de sobra. Pero tampoco hacer una clase maestra que lleve todo el peso de la aplicaci&oacute;n y que tenga 100 propiedades.</p>
<p>Vamos a proponer un ejercicio de imaginaci&oacute;n para desarrollar un ejemplo:</p>
<p>Si tenemos nuestro proyecto en orden (como fan confeso de TDD), con los test unitarios correspondientes, podemos ser capaces de medir f&aacute;cilmente la complejidad de la soluci&oacute;n. Estar&aacute; determinada por el n&uacute;mero de tests unitarios que habr&aacute; que modificar en el momento en el que se produzca un cambio.</p>
<p>Imaginemos un escenario en el que por alguna raz&oacute;n, nuestro servicio tiene que cambiar a consecuencia de una nueva especificaci&oacute;n de nuestro product owner. Algo que creemos que es com&uacute;n en los proyectos con un ciclo de vida medio/largo.</p>
<p>Si tenemos la soluci&oacute;n que usa objetos DTO espec&iacute;ficos, este cambio podr&iacute;a implicar modificar un test unitario y a su vez a&ntilde;adir una propiedad a nuestro DTO. Pero si nuestra soluci&oacute;n no sigue el SRP, es decir, que usamos los objetos POCO tambi&eacute;n como DTOs, el escenario es diferente. Cambiaremos un test, despu&eacute;s el DTO/POCO, y despu&eacute;s nos fallar&iacute;an un par de tests unitarios (por decir un n&uacute;mero) que est&aacute;n relacionados con la forma de almacenar los datos. Y para terminar tendr&iacute;amos que a&ntilde;adir, sin que tenga por qu&eacute; ser necesario, un campo m&aacute;s a nuestra base de datos. Ahora imaginemos las consecuencias de este cambio multiplicada por el n&uacute;mero de cambios que suceden en una aplicaci&oacute;n cualquiera (que no tenga un corto ciclo de vida, claro :D).</p>
<p>La conclusi&oacute;n que podemos sacar de todo esto es que el c&oacute;digo que ha resultado m&aacute;s f&aacute;cil de seguir para el resto de los programadores, m&aacute;s mantenible y en consecuencia m&aacute;s simple; ha sido el desacoplado con sus DTOs por un lado y su EF por otro. Tener una buena estructura es programar de forma simple. Si cada objeto hace lo que debe hacer, no es dif&iacute;cil entender una aplicaci&oacute;n. Si las clases empiezan a tener m&aacute;s de una responsabilidad, podremos encontrar resultados inesperados cuando hacemos un cambio.</p>
<p><strong>El principio de responsabilidad &uacute;nica nos ha llevado a hacer un c&oacute;digo m&aacute;s simple</strong>, aunque hayamos que tenido que programar m&aacute;s l&iacute;neas de c&oacute;digo. Por lo que personalmente, prefiero seguir todos los principios y hacer aplicaciones que tengan objetos POCO por un lado y DTO por otro.</p>
<p>&nbsp;</p>
<p>Y por si seguir los principios de la programaci&oacute;n no parece un argumento lo suficiente <em>s&oacute;lido</em> para argumentar separar estas dos responsabilidades en dos objetos, una reflexi&oacute;n personal: No creo que un ORM sea la soluci&oacute;n que deba ser "<em>visible</em>", si no m&aacute;s bien una "<em>pasarela</em>", porque:</p>
<ul>
<li>Si generas una serie de objetos a partir de una base de datos, estos no son la abstracci&oacute;n m&aacute;s correcta, ya que la base de datos utiliza unas herramientas totalmente diferentes a nuestra Framework de programaci&oacute;n, y se basa en otras premisas para resolver los problemas. No es lo mismo normalizar que crear un buen dominio. Y es m&aacute;s, una buena base de datos normalizada, seguro que no es el mejor dominio de una aplicaci&oacute;n.</li>
<li>Si generas la base de datos a partir de tu dominio (con EFCodeFirst, por ejemplo), la base de datos no ser&aacute; la mejor, ya que de nuevo la abstracci&oacute;n no es la m&aacute;s correcta. Y si creas un buen dominio, al convertirlo a base de datos, lo m&aacute;s probable es que no est&eacute; normalizada en absoluto.</li>
</ul>
<p>De estas dos premisas, la deducci&oacute;n que he sacado es que el acceso a datos tiene que ser una parte "<em>aislada</em>" del resto de la aplicaci&oacute;n. Est&aacute; en una capa de nuestra arquitectura llamada "persistencia". Y tendremos abstray&eacute;ndonos de este ORM a un modelo de dominio (donde aplicaremos normas de negocio) y/o de servicios (DTO, para comunic&aacute;rselo al "mundo"). De esta forma cada parte de la aplicaci&oacute;n har&aacute; lo que debe de la forma m&aacute;s eficiente para su cometido...</p>
<p></p>
<p>Eso si, como arquitectos debemos encontrar la soluci&oacute;n que m&aacute;s se adecua al escenario de nuestro proyecto. No sobre-dimensionar un programa que nos sirve para calcular n&uacute;meros primos con 5 capas. Pero tampoco crear una aplicaci&oacute;n que va a ser mantenida/expandida durante 20 a&ntilde;os y est&eacute; totalmente acoplada.</p>
<p>Ahora bien, todo esto es una opini&oacute;n que puede ser modificada por unos argumentos que consideremos mejores:</p>
<p style="text-align: center;"><strong>&iquest;Qu&eacute; opin&aacute;is vosotros?</strong></p>
<p style="text-align: center;"><strong><br /></strong></p>
<p style="font-size: 10px;">Pode&iacute;s seguir<a href="http://www.linkedin.com/groups/WCF-DTO-vs-WCF-POCO-2615616.S.89901834?qid=56f3138d-d4ae-4072-9eb3-617867092b49&amp;trk=group_most_popular-0-b-ttl&amp;goback=%2Egmp_2615616" target="_blank">&nbsp;la conversaci&oacute;n en LinkedIn</a>&nbsp;a ver en que termina derivando ya que creo que es muy interesante...</p>